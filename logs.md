# Rust 학습 로그 (Rustlings)

## 학습 일지 리스트
- [2026-02-22] 열거형(Enums) 심화: 안전한 데이터 접근 및 설계 철학
- [2026-02-21] 구조체(Structs) 및 열거형(Enums) 심화
- [2026-02-20] 소유권(Ownership) 및 이동 시맨틱(Move Semantics)
- [2026-02-19] 타입 심화(String vs &str) 및 반복자(Iterator)
- [2026-02-18] 환경 설정 및 기초 문법(if, char)

---

---

## 2026-02-22 학습 내용

### 9. 열거형(Enums) 설계와 안전성 실전

#### 열거형의 근본적인 목적: "단일 통로 관리"
- 흩어진 여러 함수(process_a, process_b...)를 호출하는 대신, 모든 명령을 하나의 열거형(Message) 봉투에 담아 하나의 함수(process)로 집중시킴.
- 중앙 집권식 관리를 통해 "할 일 목록(Queue)"을 만들거나 시스템의 상태를 일관되게 통제할 수 있음.

#### Rust vs 자바스크립트(JSON) 데이터 접근 철학
- **JS (희망 기반 접근)**: 데이터가 있을 거라 믿고 `msg.move.x`와 같이 접근. 데이터가 없으면 `undefined`를 반환하고, 실제 사용 시점에서 런타임 에러 발생.
- **Rust (확신 기반 접근)**: "신분 확인(match)" 없이는 데이터에 손도 못 대게 설계됨.
- **안전성**: match 문은 모든 케이스를 다루도록 강제(Exhaustiveness)하므로, 데이터 구조가 바뀌거나 타입이 누락되었을 때 컴파일 단계에서 즉시 발견 가능.

#### 동작 메커니즘: &mut self와 주인공(Instance)
- **주인공 생성**: `let mut state = State { ... };` 메모리에 실제 데이터 판이 깔림.
- **명령 하달**: `state.process(Message::...)` 호출 시, `state`는 `self`라는 이름으로 함수에 대여됨.
- **수행**: `&mut self`는 원본을 가리키는 '긴 장갑'과 같아서, 함수 내부에서 `self.width = ...`를 수행하면 멀리 있는 원본 `state`의 값이 직접 수정됨.

#### 구조체(AND) vs 열거형(OR)
- **구조체**: 데이터의 **구성 요소**를 정의. (A 와 B 와 C가 모두 실재함)
- **열거형**: 데이터의 **정체/상태**를 정의. (A 혹은 B 혹은 C 중 딱 하나만 실재함)
- **결합**: 서로 다른 모양의 구조체들을 열거형이라는 큰 봉투에 담아 전달함으로써, 타입의 통일성과 데이터의 독립성을 동시에 확보(Sum Type).

#### 시스템 설계의 0단계: 설계도
- 런타임에 즉흥적으로 데이터를 생성하는 것이 아니라, 구조체(데이터)와 열거형(메시지 체계), impl(능력)을 사전에 엄격히 정의해야 함.
- 이 엄격함이 "실행 중에 데이터 구조 문제로 프로그램이 죽는 일"을 원천 차단함.

#### 구문적 특징: 중괄호`{}` vs 소괄호`()`
- **Enum/Struct 세계 (`{}`)**: 데이터의 모양이나 상자를 설계/생성/해체할 때 사용. 설계도에 중괄호를 썼다면 사용할 때도 중괄호를 써서 필드명을 맞춰야 함.
- **함수/메서드 세계 (`()`)**: 기계나 동작을 가동할 때 사용. 인자를 전달하는 '행위'를 의미함.
- **연결**: `match` 문에서 Enum 상자를 `{}`로 뜯어 알맹이를 꺼낸 뒤, 그 알맹이를 함수의 `()`에 집어넣는 식으로 두 세계가 연결됨.

#### 명령형(Imperative) vs 선언형(Declarative) 명령
- **직설적 명령 (동사)**: `move_hero(x, y)` - 즉시 실행되는 행위. 로그 기록이나 취소가 어렵고 실행 시점에 종속됨.
- **데이터화된 명령 (명사)**: `Command::Move { x, y }` - 행위의 의도를 데이터로 캡슐화한 것.
- **장점**: 명령을 변수에 담아 보관(로그), 멀리 전송(네트워크), 나중에 실행(지연), 실행 취소(Undo) 등이 가능해져 시스템의 유연성이 극대화됨.

---

## 2026-02-21 학습 내용

### 6. 구조체 (Structs)

#### 구조체의 세 가지 형태
- 일반 구조체 (Regular Struct): 관례적인 필드 이름을 가짐. `struct Color { red: u32, ... }`
- 튜플 구조체 (Tuple Struct): 필드 이름 없이 순서(인덱스)로 접근. `struct Color(u32, u32, u32);`
- 유닛 구조체 (Unit Struct): 필드가 전혀 없는 구조체. 데이터 저장보다는 타입 그 자체의 존재나 특정 능력을 부여할 때 사용. `struct Unit;`

#### 구조체 업데이트 구문 (..)
- 기존 구조체 인스턴스의 값을 바탕으로 새로운 인스턴스를 만들 때 사용.
- 바꿀 필드만 명시하고 나머지는 `..원본` 문법으로 일괄 처리 가능.
- 주의: 소유권이 있는 타입(String 등)을 명시적으로 적지 않고 `..`에 맡기면 소유권이 새 인스턴스로 이동됨.

#### derive(Debug)와 {:?}
- 구조체는 기본적으로 출력 기능이 없음.
- `#[derive(Debug)]`를 구조체 위에 선언하면 컴파일러가 출력용 코드를 자동으로 생성함.
- `println!("{:?}", 변수)`처럼 `{:?}` 포맷과 함께 사용하여 내부 값을 확인 가능.

### 7. 소유권과 타입 특성

#### Copy 트레이트와 값 복사
- 숫자(i32, u32 등), 불리언(bool), 문자(char) 등 크기가 고정된 가벼운 타입은 소유권이 이동하지 않고 **복사**됨.
- 따라서 숫자를 함수 인자로 넘겨도 호출한 쪽에서 원본을 계속 사용할 수 있음.

#### 함수의 반환 법칙
- 함수 내부 마지막 줄에 세미콜론(`;`)이 없으면 해당 줄의 결과값이 함수 밖으로 반환됨.
- 세미콜론이 있으면 값이 소멸되고 `()` (Unit) 타입을 반환하게 됨.

#### 에러 코드 E0308
- 타입 불일치(Mismatched Types) 상황에서 발생.
- 컴파일러가 기대한 타입(expected)과 실제 발견된 타입(found)을 비교하여 알려줌.

### 8. 열거형 (Enums)

#### 열거형의 정의와 특징
- 관련된 여러 선택지(변체, Variants)를 하나의 타입으로 묶음.
- 각 변체는 서로 다른 형태의 데이터를 담을 수 있음 (단순 이름, 튜플 형태, 구조체 형태).

#### 데이터 활용 방식
- 재사용 방식 (Recommended): 외부의 구조체를 타입으로 사용. `Move(Point)`
- 인라인 방식: 열거형 내부에 직접 필드를 정의. `Resize { width: i32, height: i32 }`
- 장점: 익명 데이터를 즉석에서 정의하는 것보다 이미 정의된 타입(Point 등)을 재활용하는 것이 기능 확장성 면에서 뛰어남.

#### 열거형의 impl 구현
- 구조체와 마찬가지로 열거형에도 `impl` 블록을 통해 메서드를 추가할 수 있음.
- 데이터(Enum)와 그 데이터를 다루는 로직(impl)을 분리하여 응집력 있는 설계가 가능함.
- 예: DB에서 가져온 상태(Enum)에 따라 사용자 메시지를 동적으로 생성하는 기능을 impl에 구현.

#### 안전한 데이터 접근
- JSON처럼 `message.move.x`와 같이 직접 접근하는 것은 불가능함.
- 현재 열거형이 어떤 상태인지 모르기 때문에, 반드시 패턴 매칭(match 등)을 통해 안전하게 데이터를 꺼내 써야 함.

---

## 2026-02-20 학습 내용

### 4. 소유권 (Ownership) & 이동 시맨틱 (Move Semantics)

#### 이동 (Move)
- 변수를 다른 변수에 대입하거나 함수 인자로 넘기면 소유권(집문서)이 통째로 넘어간다.
- 넘겨준 원본 변수는 더 이상 쓸 수 없다. (Shadowing이나 Copy 트레이트가 없는 한)

#### 참조/대여 (Borrowing)
- &를 붙여 주소표만 건네주는 행위. 원본 소유권은 그대로 유지된다.
- 불변 참조(&): 여러 명이 동시에 구경은 가능하지만 수정은 불가.
- 가변 참조(&mut): 딱 한 명만 빌려서 수정할 수 있음.

#### 수정(Push)과 메모리 주소
- Vec이나 String에 데이터를 push할 때, 메모리 여유 공간이 있다면 주소는 유지된 채 내용만 업데이트된다.
- 소유권이 이동(Move)한다고 메모리 주소가 매번 바뀌는 것이 아니라, 집문서 명의자만 바뀌고 집(메모리 주소)은 그대로인 경우가 많아 효율적이다.

#### 인자로 전달 시 매개변수에서 소유권 이동과 동시에 가변성 확보
- 함수의 매개변수에 `mut vec: Vec<i32>`와 같이 작성.

#### 가변 참조자(&mut)와 대여 규칙(Borrowing Rules)
- &mut x: 원본을 파괴하지 않고 주소를 찾아가서 내용물을 수정할 수 있는 독점적인 권한을 빌려오는 것.
- 독점권: 어떤 값에 대해 가변 참조자(&mut)가 활성화되어 있다면, 그 시점에는 오직 그 한 명만 값을 보거나 고칠 수 있다.
- 제약 사항: 동일한 값에 대해 두 개 이상의 가변 참조자를 동시에 가질 수 없다. (동시에 물건을 고치려 할 때 발생하는 데이터 충돌 방지)
- 해결법: 가변 참조자의 사용 범위를 겹치지 않게 순서를 조정하거나, 사용이 끝난 뒤 다음 참조를 선언해야 한다.

#### 소유권 대여와 데이터 재사용 (move_semantics5)
- 조회 작업 시 &를 사용하여 대여(Borrow)하면, 함수 종료 후에도 소유권이 유지되어 원본 데이터를 다른 함수(예: 소유권을 가져가는 변환 함수)에서 다시 사용할 수 있다.
- 함수 선언에 반환 타입(-> T)을 명시했다면, 바디 마지막에 해당 타입의 값을 반드시 반환해야 한다. 단순히 출력만 하고 결과를 외부에서 쓰지 않는다면 반환 타입을 제거해도 무방하다.
- println! 매크로 사용 시 주의: `println!("{}", value)`와 같이 포맷 문자열을 반드시 첫 번째 인자로 사용해야 한다.

---

## 2026-02-19 학습 내용

### 2. 타입 시스템 심화 (String vs &str)

#### &str (String Slice - 비석에 새긴 각인)
- 프로그램 바이너리에 박혀 있음. 메모리를 따로 빌릴 필요 없이 주소만 알면 되기에 빠름.
- 읽기 전용이며 크기를 키우거나 내용을 고칠 수 없음.

#### String (Owned String - 이동식 칠판)
- 실행 중 힙(Heap) 메모리에 할당됨. 내용을 수정하거나 크기를 늘릴 수 있음.
- 소유권(집문서)이 명확히 존재하며, 주인을 따라다니며 책임짐.

#### 실무 팁
- 데이터를 생성/저장하거나 DB에서 가져올 때는 String을 사용.
- 함수 인자로 읽기 전용 데이터를 넘길 때는 &str을 사용하는 것이 국룰 (유연성 및 효율성).

### 5. 유용한 도구들

#### 반복자 (Iterator)
- `input.iter().map(|x| x + 1).collect()`
- iter(): 데이터를 하나씩 꺼낼 준비 (도우미 호출)
- map(): 꺼낼 때마다 어떻게 가공할지 명령 (게으른 연산: 실제론 이때 안 일어남)
- collect(): 드디어 실제로 가공해서 새 바구니에 담기 (실행 시점, 반환 타입 기반으로 그릇 결정)

---

## 2026-02-18 학습 내용

### 1. 환경 설정 및 기초 문법

#### rust-analyzer 설정 (학습 효율화)
- 문제: 의도된 에러가 많은 학습 프로젝트에서는 실시간 진단이 번거로울 수 있음.
- 해결: 워크스페이스 단위(Disable Workspace)로 비활성화하여 rustlings watch 피드백에 집중하는 환경 구축.

#### if 표현식
- Rust에서 if는 표현식(Expression)이다. 즉, 값을 반환할 수 있다.
- 모든 분기(if, else if, else)는 반드시 동일한 타입을 반환해야 한다.

#### 문자(char)
- 작은따옴표(') 사용. 4바이트 유니코드 지원으로 한글이나 특수 문자도 가뿐히 담음.

### 3. 매크로 (Macro) vs 함수 (Function)

#### 매크로의 정체 (!)
- 컴파일 시점의 마법: 컴파일러가 실행 파일이 만들어지기 전, 짧은 코드(println!)를 사전에 정의된 복잡한 코드로 확장(Expand)해줌.
- 사용 이유: 가변 인자 처리, 코드 자동 생성, 컴파일 타임의 세밀한 제어.
- 명시성: 이름 뒤에 !를 붙여 일반 함수와 시각적으로 구분함.
