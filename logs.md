# Rust 학습 로그 (Rustlings)

## 학습 일지 리스트
- [2026-02-18] 환경 설정 및 기초 문법 (if, char)
- [2026-02-19] 타입 심화 (String vs &str) 및 반복자 (Iterator)
- [2026-02-20] 소유권 (Ownership) 및 이동 시맨틱 (Move Semantics)

---

## 2026-02-20 학습 내용

### 4. 소유권 (Ownership) & 이동 시맨틱 (Move Semantics)

#### 이동 (Move)
- 변수를 다른 변수에 대입하거나 함수 인자로 넘기면 소유권(집문서)이 통째로 넘어간다.
- 넘겨준 원본 변수는 더 이상 쓸 수 없다. (Shadowing이나 Copy 트레이트가 없는 한)

#### 참조/대여 (Borrowing)
- &를 붙여 주소표만 건네주는 행위. 원본 소유권은 그대로 유지된다.
- 불변 참조(&): 여러 명이 동시에 구경은 가능하지만 수정은 불가.
- 가변 참조(&mut): 딱 한 명만 빌려서 수정할 수 있음.

#### 수정(Push)과 메모리 주소
- Vec이나 String에 데이터를 push할 때, 메모리 여유 공간이 있다면 주소는 유지된 채 내용만 업데이트된다.
- 소유권이 이동(Move)한다고 메모리 주소가 매번 바뀌는 것이 아니라, 집문서 명의자만 바뀌고 집(메모리 주소)은 그대로인 경우가 많아 효율적이다.

#### 인자로 전달 시 매개변수에서 소유권 이동과 동시에 가변성 확보
- 함수의 매개변수에 `mut vec: Vec<i32>`와 같이 작성.

---

## 2026-02-19 학습 내용

### 2. 타입 시스템 심화 (String vs &str)

#### &str (String Slice - 비석에 새긴 각인)
- 프로그램 바이너리에 박혀 있음. 메모리를 따로 빌릴 필요 없이 주소만 알면 되기에 빠름.
- 읽기 전용이며 크기를 키우거나 내용을 고칠 수 없음.

#### String (Owned String - 이동식 칠판)
- 실행 중 힙(Heap) 메모리에 할당됨. 내용을 수정하거나 크기를 늘릴 수 있음.
- 소유권(집문서)이 명확히 존재하며, 주인을 따라다니며 책임짐.

#### 실무 팁
- 데이터를 생성/저장하거나 DB에서 가져올 때는 String을 사용.
- 함수 인자로 읽기 전용 데이터를 넘길 때는 &str을 사용하는 것이 국룰 (유연성 및 효율성).

### 5. 유용한 도구들

#### 반복자 (Iterator)
- `input.iter().map(|x| x + 1).collect()`
- iter(): 데이터를 하나씩 꺼낼 준비 (도우미 호출)
- map(): 꺼낼 때마다 어떻게 가공할지 명령 (게으른 연산: 실제론 이때 안 일어남)
- collect(): 드디어 실제로 가공해서 새 바구니에 담기 (실행 시점, 반환 타입 기반으로 그릇 결정)

---

## 2026-02-18 학습 내용

### 1. 환경 설정 및 기초 문법

#### rust-analyzer 설정 (학습 효율화)
- 문제: 의도된 에러가 많은 학습 프로젝트에서는 실시간 진단이 번거로울 수 있음.
- 해결: 워크스페이스 단위(Disable Workspace)로 비활성화하여 rustlings watch 피드백에 집중하는 환경 구축.

#### if 표현식
- Rust에서 if는 표현식(Expression)이다. 즉, 값을 반환할 수 있다.
- 모든 분기(if, else if, else)는 반드시 동일한 타입을 반환해야 한다.

#### 문자(char)
- 작은따옴표(') 사용. 4바이트 유니코드 지원으로 한글이나 특수 문자도 가뿐히 담음.

### 3. 매크로 (Macro) vs 함수 (Function)

#### 매크로의 정체 (!)
- 컴파일 시점의 마법: 컴파일러가 실행 파일이 만들어지기 전, 짧은 코드(println!)를 사전에 정의된 복잡한 코드로 확장(Expand)해줌.
- 사용 이유: 가변 인자 처리, 코드 자동 생성, 컴파일 타임의 세밀한 제어.
- 명시성: 이름 뒤에 !를 붙여 일반 함수와 시각적으로 구분함.
